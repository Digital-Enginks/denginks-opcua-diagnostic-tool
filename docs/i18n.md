# Internationalization (i18n) System

The application uses a custom, lightweight, type-safe internationalization system located in `src/utils/i18n.rs`.

## Design

Instead of using external string files (like JSON or PO), translations are embedded directly in the binary using Rust enums and match expressions. This ensures:
1.  **Type Safety:** No missing keys at runtime. The compiler enforces that every key exists.
2.  **Performance:** Zero parsing overhead at runtime.
3.  **Simplicity:** No external dependencies required.

## Structure

### The `Language` Enum
Defines the supported languages:
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Language {
    English,
    Spanish,
}
```

### The `T` Enum (Translation Keys)
Every translatable string in the UI corresponds to a variant in the `T` enum.
```rust
pub enum T {
    File,
    Exit,
    Connect,
    // ...
}
```

### The `t()` Function
The core function that resolves a key to a string based on the selected language.

```rust
pub fn t(key: T, lang: Language) -> &'static str {
    match key {
        T::File => match lang {
            Language::English => "File",
            Language::Spanish => "Archivo",
        },
        // ...
    }
}
```

## Usage

In the UI code, strings are never hardcoded. Instead, the `t()` function is used:

```rust
ui.label(t(T::Connect, self.settings.language));
```

## Adding a New Translation

1.  Add a new variant to the `T` enum in `src/utils/i18n.rs`.
2.  Add the corresponding match arm in the `t()` function implementation.
3.  Provide the string for both `Language::English` and `Language::Spanish`.
4.  The compiler will error if you miss a language, ensuring complete coverage.
